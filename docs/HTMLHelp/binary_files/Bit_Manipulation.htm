<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">

<html>

<!--(==============================================================)-->
<!--(Document created with RoboEditor. )============================-->
<!--(==============================================================)-->

<head>

<title>Bit Manipulation</title>

<!--(Meta)==========================================================-->

<meta http-equiv=content-type content="text/html; charset=windows-1252">
<meta name=generator content="RoboHELP by eHelp Corporation - www.ehelp.com">
<meta name=generator-major-version content=0.1>
<meta name=generator-minor-version content=1>
<meta name=filetype content=kadov>
<meta name=filetype-version content=1>
<meta name=page-count content=1>
<meta name=layout-height content=1082>
<meta name=layout-width content=1564>


<!--(Links)=========================================================-->

<link rel="StyleSheet" href="..\Hexedit.css">



</head>

<!--(Body)==========================================================-->


<body>

<h2><font style="font-family: Arial;"
			face=Arial>Bit Manipulation</font></h2>

<p>&nbsp;</p>

<p style="font-weight: bold;">Bit Masking</p>

<p>&nbsp;</p>

<p>Using the Boolean operations discussed earlier you can isolate a bit 
 or bits within a byte. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->For 
 example, you may want to test whether a bit is on, or work with a bitfield 
 (a group of bits within a byte, bitfields are discussed in a later section). 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->To turn 
 all bits off except the bits you are interested in you can use AND. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->To 
 turn a bit off you simply AND that bit with FALSE; to leave a bit unchanged 
 AND it with TRUE.</p>

<p>&nbsp;</p>

<p>Few processors have instructions for testing the values of individual 
 bits. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Even 
 if they do high level languages such as C do not. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Typically 
 the bits to be ignored in the byte are masked using AND, then the result 
 is tested for zero. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->(Processors 
 invariably have an instruction for checking whether a byte is zero, ie, 
 has all bits off.)</p>

<p>&nbsp;</p>

<p>Similarly, OR can be used for turning some bits on while not changing 
 others. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->And 
 XOR (exclusive-OR) can be used for toggling certain bits while not changing 
 others.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p style="font-weight: bold;">Rotations</p>

<p>&nbsp;</p>

<p>Another group of basic operations are shifts and rotations. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Unlike 
 the Boolean operations these must operate on a group of bits together, 
 usually a byte, word etc. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Essentially, 
 they are all involved in moving the bits left or right in the group of 
 bits.</p>

<p>&nbsp;</p>

<p>Rotate operations move all the bits left or right and the bits that 
 fall off the end are put back into the other end. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->See 
 the diagrams below. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Rotations 
 are not as useful as shifts but you can use a rotation as an alternative 
 to a mask for testing the value of individual bits.</p>

<p>&nbsp;</p>

<p>To test whether a bit is on you simply rotate the byte until the desired 
 bit is in the most significant bit and then check if the byte is -ve. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->All processors 
 have an instruction to test whether a value is -ve by testing the most 
 significant bit.</p>

<p>&nbsp;</p>

<p style="text-align: center;"
	align=center><img src="ROL.gif"
						style="border-style: none;
								border: none;
								width: 294px;
								height: 59px;"
						width=294
						height=59
						border=0> <!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span 
 style="text-align: center;"><!--kadov_tag{{</spaces>}}--><img src="ROR.gif"
	style="border-style: none;
			border: none;
			width: 294px;
			height: 59px;"
	width=294
	height=59
	border=0></span></p>

<p style="text-align: center; font-weight: bold;"
	align=center>Figure 2. Rotate Left and Rotate Right.</p>

<p>&nbsp;</p>

<p>In the <span class=HexEdit>HexEdit </span>calculator the ROL button 
 does a rotate left and the ROR button does a rotate right. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Both 
 take two operands: the number to be rotated and the number of bit positions 
 to rotate. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 ROL1 and ROR1 just take one operand and rotate by one bit only.</p>

<p>&nbsp;</p>

<p style="font-weight: bold;"><span style="font-weight: bold;">Shift Operations</span></p>

<p>&nbsp;</p>

<p>Shifts operate similarly to rotations but the bits that fall off the 
 end are thrown away. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 new bits to be added are usually zero, except for the case of arithmetic 
 shift right (discussed below).</p>

<p>&nbsp;</p>

<p>Shift operations are used in hardware as part of multiplication and 
 division. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->In 
 fact a left shift is equivalent to integer multiplication by a power of 
 two; a right shift is equivalent to integer division by a power of two. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->A right 
 shift by one bit doubles the number, a right shift by two bits multiplies 
 by four, three bits multiplies by 8 etc. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Similarly 
 a right shift one bit divides by two, a right shift by two bits divides 
 by four etc.</p>

<p>&nbsp;</p>

<p>With division the fact that the least significant bit(s) are thrown 
 away in a shift right means that no allowance is made for keeping a remainder. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->In integer 
 arithmetic both six and seven when divided by two both give the result 
 three. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->With 
 multiplication if a thrown away bit is on (TRUE) then this is an arithmetic 
 overflow condition.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p style="text-align: center;"
	align=center><img src="LSL.gif"
						style="border-style: none;
								border: none;
								width: 294px;
								height: 59px;"
						width=294
						height=59
						border=0> <!--kadov_tag{{<spaces>}}-->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--kadov_tag{{</spaces>}}--><img 
 src="LSR.gif"
	style="border-style: none;
			border: none;
			width: 294px;
			height: 59px;"
	width=294
	height=59
	border=0></p>

<p style="text-align: center; font-weight: bold;"
	align=center>Figure 3. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Shift 
 Left and Shift Right.</p>

<p>&nbsp;</p>

<p>Shift left and shift right are often called &quot;logical shift left&quot; 
 or LSL and &quot;logical shift right&quot; or LSR, to distinguish them 
 from arithmetic shifts (explained below).</p>

<p>&nbsp;</p>

<p>In the <span class=HexEdit>HexEdit </span>calculator the LSL button 
 does a shift left and the LSR button does a shift right. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Both 
 take two operands: the number to be changed and the number of bit positions 
 to shift. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->The 
 LSL1 and LSR1 just take one operand and shift by one bit only.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>As you saw in the last section, numbers can be considered signed or 
 unsigned. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->When 
 signed, the top (most significant) bit indicates whether the number is 
 negative. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Logical 
 shift right puts a zero in the top most bit which obviously means it does 
 not give the correct result for integer division of negative numbers. 
 <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->It turns 
 out that this is easily accomplished for signed (2's complement) numbers 
 using sign-propagation, where the previous value of the sign bit (ie, 
 top bit) is put back into the top bit rather than zero. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Arithmetic 
 shift right is the same as logical shift right except that the new value 
 for the sign bit comes from the previous value rather than always being 
 zero.</p>

<p>&nbsp;</p>

<p style="text-align: center;"
	align=center><img src="ASR.gif"
						style="border-style: none;
								border: none;
								width: 294px;
								height: 59px;"
						width=294
						height=59
						border=0></p>

<p style="text-align: center; font-weight: bold;"
	align=center>Figure 4. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->Arithmetic 
 Shift Right.</p>

<p>&nbsp;</p>

<p>In the <span class=HexEdit>HexEdit </span>calculator the ASR button 
 does an arithmetic shift right. <!--kadov_tag{{<spaces>}}-->&nbsp;<!--kadov_tag{{</spaces>}}-->And 
 the ASR1 button shifts its operand by one bit.</p>

<p>&nbsp;</p>

<p><span style="font-weight: bold;">Next topic:</span> <a HREF="Floating_Point_Numbers.htm">Floating 
 Point Numbers</a></p>

<p>&nbsp;</p>

</body>

</html>
